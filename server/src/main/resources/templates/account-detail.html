<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="'Account ' + ${account.accountId} + ' - Trade Monitor v1.1'">Account Detail - Trade Monitor</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
    <style>
        /* Filter Buttons */
        .filter-bar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: var(--bg-card);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
        }

        .filter-btn.active {
            background: var(--accent-primary);
            color: #ffffff;
            border-color: var(--accent-primary);
        }

        .trade-comment {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .trade-today {
            background-color: rgba(99, 102, 241, 0.12) !important;
            /* Subtle primary tint */
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <a href="/" class="back-link">‚Üê Zur√ºck zum Dashboard</a>

            <div style="display: flex; flex-direction: column; gap: 5px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="badg-mini" style="font-family: 'JetBrains Mono'; font-size: 1.35rem; color: #a0a0c0;"
                        th:text="'#' + ${account.accountId}">#12345</span>
                    <span th:class="${online ? 'status-badge online' : 'status-badge offline'}"
                        th:text="${online ? 'ONLINE' : 'OFFLINE'}">ONLINE</span>
                    <span th:if="${account.type == 'REAL'}" class="badge-mini real"
                        style="font-size: 0.8rem; padding: 2px 6px;">REAL</span>
                </div>

                <h1 th:text="${account.name != null && !account.name.isEmpty() ? account.name : 'Account ' + account.accountId}"
                    th:style="${account.name == 'FXSSI10_KI'} ? 'margin: 5px 0 0 0; font-size: 2.5rem; color: #ffd700;' : 'margin: 5px 0 0 0; font-size: 2.5rem;'">
                    Currency Pair / Strategy Name</h1>

                <p class="subtitle" th:text="${account.broker}" style="margin-top: 5px;">Broker Name</p>
            </div>
        </header>

        <div class="account-summary">
            <div class="filter-bar" id="history-filter-bar" style="flex-basis: 100%; margin-bottom: 1rem;">
                <button class="filter-btn" data-range="today">Heute</button>
                <button class="filter-btn" data-range="1week">1 Woche</button>
                <button class="filter-btn" data-range="1month">1 Monat</button>
                <button class="filter-btn" data-range="thismonth">Aktueller Monat</button>
                <button class="filter-btn" data-range="6months">6 Monate</button>
                <button class="filter-btn" data-range="thisyear">Dieses Jahr</button>
                <button class="filter-btn" data-range="1year">1 Jahr</button>
                <button class="filter-btn" data-range="all">Alles</button>
            </div>
            <div class="summary-card">
                <span class="summary-label">Balance</span>
                <span class="summary-value"
                    th:text="${#numbers.formatDecimal(account.balance, 1, 2)} + ' ' + ${account.currency}">10,000.00
                    USD</span>
            </div>
            <div class="summary-card">
                <span class="summary-label">Equity</span>
                <span class="summary-value"
                    th:text="${#numbers.formatDecimal(account.equity, 1, 2)} + ' ' + ${account.currency}">10,500.00
                    USD</span>
            </div>
            <div class="summary-card">
                <span class="summary-label">Floating P/L</span>
                <span
                    th:class="${account.totalProfit >= 0 ? 'summary-value profit-positive' : 'summary-value profit-negative'}"
                    th:text="${#numbers.formatDecimal(account.totalProfit, 1, 2)} + ' ' + ${account.currency}">+500.00
                    USD</span>
            </div>
            <div class="summary-card">
                <span class="summary-label">Open Trades</span>
                <span class="summary-value" th:text="${#lists.size(account.openTrades)}">5</span>
            </div>
        </div>

        <!-- ======= DASHBOARD (Chart + Stats) ======= -->
        <section class="trades-section dashboard-section">
            <h2>üìú Trade Historie / Dashboard</h2>

            <div class="chart-container"
                style="position: relative; height: 300px; margin-bottom: 2rem; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem;">
                <canvas id="balance-history-chart"></canvas>
            </div>

            <!-- Statistics Grid -->
            <div class="stats-grid"
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                <div class="stat-card"
                    style="background: var(--bg-card); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Gesamtgewinn</span>
                    <span id="stat-total-profit" style="font-size: 1.25rem; font-weight: bold;">0.00</span>
                </div>
                <div class="stat-card"
                    style="background: var(--bg-card); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Profit
                        Faktor</span>
                    <span id="stat-profit-factor" style="font-size: 1.25rem; font-weight: bold;">0.00</span>
                </div>
                <div class="stat-card"
                    style="background: var(--bg-card); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Trefferquote</span>
                    <span id="stat-win-rate" style="font-size: 1.25rem; font-weight: bold;">0%</span>
                </div>
                <div class="stat-card"
                    style="background: var(--bg-card); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Trades
                        (Zeitraum)</span>
                    <span id="stat-total-trades" style="font-size: 1.25rem; font-weight: bold;">0</span>
                </div>
                <div class="stat-card"
                    style="background: var(--bg-card); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">√ò
                        Win / √ò Loss</span>
                    <span id="stat-avg-win-loss" style="font-size: 1rem; font-weight: bold;">0 / 0</span>
                </div>
                <!-- Static / Current Stats -->
                <div class="stat-card"
                    style="background: rgba(99, 102, 241, 0.1); padding: 1rem; border-radius: 8px; border: 1px solid var(--accent-primary); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Open
                        Equity (Aktuell)</span>
                    <span th:class="${account.totalProfit >= 0 ? 'profit-positive' : 'profit-negative'}"
                        th:text="${#numbers.formatDecimal(account.totalProfit, 1, 2)}"
                        style="font-size: 1.25rem; font-weight: bold;">0.00</span>
                </div>
                <div class="stat-card"
                    style="background: rgba(99, 102, 241, 0.1); padding: 1rem; border-radius: 8px; border: 1px solid var(--accent-primary); text-align: center;">
                    <span
                        style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Open
                        Trades (Aktuell)</span>
                    <span th:text="${#lists.size(account.openTrades)}"
                        style="font-size: 1.25rem; font-weight: bold;">0</span>
                </div>
            </div>
        </section>

        <!-- ======= OPEN TRADES (paginated) ======= -->
        <section class="trades-section">
            <h2>üìà Offene Positionen</h2>

            <div th:if="${#lists.size(account.openTrades) == 0}" class="no-trades">
                <p>Keine offenen Positionen</p>
            </div>

            <div th:if="${#lists.size(account.openTrades) > 0}" class="paginated-table-wrapper"
                id="open-trades-wrapper">
                <table class="trades-table" id="open-trades-table">
                    <thead>
                        <tr>
                            <th>Ticket</th>
                            <th>Symbol</th>
                            <th>Typ</th>
                            <th>Volume</th>
                            <th>Open Price</th>
                            <th>Time</th>
                            <th>S/L</th>
                            <th>T/P</th>
                            <th>Swap</th>
                            <th>Profit</th>
                            <th>Magic</th>
                            <th>Status.</th>
                            <th>Comment</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr th:each="trade : ${account.openTrades}">
                            <td th:text="${trade.ticket}">123456789</td>
                            <td><strong th:text="${trade.symbol}">EURUSD</strong></td>
                            <td>
                                <span th:class="${trade.type == 'BUY' ? 'trade-type buy' : 'trade-type sell'}"
                                    th:text="${trade.type}">BUY</span>
                            </td>
                            <td th:text="${trade.volume}">0.10</td>
                            <td th:text="${trade.openPrice}">1.08500</td>
                            <td th:text="${trade.openTime}">2026-02-13 12:00</td>
                            <td th:text="${trade.stopLoss}">1.08000</td>
                            <td th:text="${trade.takeProfit}">1.09000</td>
                            <td th:text="${#numbers.formatDecimal(trade.swap, 1, 2)}">-1.20</td>
                            <td th:class="${trade.profit >= 0 ? 'profit-positive' : 'profit-negative'}"
                                th:text="${#numbers.formatDecimal(trade.profit, 1, 2)}">+45.50</td>
                            <td th:text="${trade.magicNumber}">12345</td>
                            <td>
                                <span th:if="${account.type == 'REAL'}">
                                    <span th:if="${trade.syncStatus == 'MATCHED'}" class="check-icon"
                                        title="Matched with Demo">‚úÖ</span>
                                    <span th:if="${trade.syncStatus == 'WARNING'}" class="warning-icon"
                                        title="No matching Demo trade!">‚ö†Ô∏è</span>
                                </span>
                            </td>
                            <td class="trade-comment" th:text="${trade.comment}">Example Comment</td>
                        </tr>
                    </tbody>
                </table>
                <div class="pagination-bar" id="open-trades-pagination"></div>
            </div>
        </section>

        <!-- ======= MAGIC NUMBER PROFIT BREAKDOWN ======= -->
        <section class="trades-section magic-breakdown" th:if="${#lists.size(magicProfits) > 0}">
            <h2>üìä Gewinn pro Magic Number <span id="magic-breakdown-period"
                    style="font-size: 0.8em; color: var(--text-secondary); font-weight: normal;"></span></h2>

            <table class="trades-table">
                <thead>
                    <tr>
                        <th>Magic Number</th>
                        <th>Offene Trades</th>
                        <th>Float. P/L</th>
                        <th>Geschl. Trades</th>
                        <th>Real. P/L</th>
                        <th>Gesamt</th>
                    </tr>
                </thead>
                <tbody>
                    <tr th:each="mp : ${magicProfits}">
                        <td>
                            <strong th:text="${mp.magicNumber}">12345</strong>
                            <div th:if="${mp.magicName != null && !mp.magicName.isEmpty()}"
                                style="font-size: 0.85rem; color: #a0a0c0; margin-top: 2px;" th:text="${mp.magicName}">
                                Strategy Name
                            </div>
                        </td>
                        <td th:text="${mp.openTradeCount}">3</td>
                        <td th:class="${mp.openProfit >= 0 ? 'profit-positive' : 'profit-negative'}"
                            th:text="${#numbers.formatDecimal(mp.openProfit, 1, 2)}">+100.00</td>
                        <td th:text="${mp.closedTradeCount}">10</td>
                        <td th:class="${mp.closedProfit >= 0 ? 'profit-positive' : 'profit-negative'}"
                            th:text="${#numbers.formatDecimal(mp.closedProfit, 1, 2)}">+500.00</td>
                        <td th:class="${mp.totalProfit >= 0 ? 'profit-positive' : 'profit-negative'}"
                            th:text="${#numbers.formatDecimal(mp.totalProfit, 1, 2)}">+600.00</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- ======= MAGIC NUMBER PROFIT CURVES ======= -->
        <section class="trades-section magic-charts" th:if="${magicCurveJson != '{}'}">
            <h2>üìà Gewinnkurven pro Magic Number <span id="magic-curves-period"
                    style="font-size: 0.8em; color: var(--text-secondary); font-weight: normal;"></span></h2>
            <div id="magic-charts-container"></div>
        </section>

        <!-- Fullscreen chart modal -->
        <div id="chart-modal" class="chart-modal">
            <div class="chart-modal-content">
                <button class="chart-modal-close" id="chart-modal-close">‚úï</button>
                <h2 id="chart-modal-title" class="chart-modal-title"></h2>
                <div class="chart-modal-canvas-wrap">
                    <canvas id="chart-modal-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- ======= CLOSED TRADES HISTORY (filtered & paginated) ======= -->
        <section class="trades-section history-section">
            <h2>üìú Geschlossene Trades Liste</h2>



            <div th:if="${#lists.size(account.closedTrades) == 0}" class="no-trades">
                <p>Keine geschlossenen Trades vorhanden</p>
            </div>

            <div class="history-summary" id="history-summary" th:if="${#lists.size(account.closedTrades) > 0}">
                <span>Angezeigt: <strong id="visible-trades-count">0</strong> Trades</span>
                <span id="visible-profit-label" class="profit-positive">
                    Profit: <strong id="visible-profit-amount">0.00</strong> <span
                        th:text="${account.currency}">EUR</span>
                </span>
            </div>

            <div th:if="${#lists.size(account.closedTrades) > 0}" class="paginated-table-wrapper"
                id="closed-trades-wrapper">
                <table class="trades-table" id="closed-trades-table">
                    <thead>
                        <tr>
                            <th>Ticket</th>
                            <th>Symbol</th>
                            <th>Typ</th>
                            <th>Volume</th>
                            <th>Close Time</th>
                            <th>Close Price</th>
                            <th>Swap</th>
                            <th>Commission</th>
                            <th>Profit</th>
                            <th>Magic</th>
                            <th>Comment</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Loop all closed trades, rows will be filtered by JS -->
                        <tr th:each="trade : ${account.closedTrades}" th:data-close-time="${trade.closeTime}"
                            th:classappend="${trade.closeTime != null && trade.closeTime.startsWith(todayDate)} ? 'trade-today'">
                            <td th:text="${trade.ticket}">123456789</td>
                            <td><strong th:text="${trade.symbol}">EURUSD</strong></td>
                            <td>
                                <span th:class="${trade.type == 'BUY' ? 'trade-type buy' : 'trade-type sell'}"
                                    th:text="${trade.type}">BUY</span>
                            </td>
                            <td th:text="${trade.volume}">0.10</td>
                            <td th:text="${trade.closeTime}">2026-02-09 10:30:00</td>
                            <td th:text="${trade.closePrice}">1.08600</td>
                            <td th:text="${#numbers.formatDecimal(trade.swap, 1, 2)}">-1.20</td>
                            <td th:text="${#numbers.formatDecimal(trade.commission, 1, 2)}">-0.70</td>
                            <td class="profit-cell" th:data-profit="${trade.profit}"
                                th:classappend="${trade.profit >= 0 ? 'profit-positive' : 'profit-negative'}"
                                th:text="${#numbers.formatDecimal(trade.profit, 1, 2)}">+45.50</td>
                            <td th:text="${trade.magicNumber}">12345</td>
                            <td class="trade-comment" th:text="${trade.comment}">Example Comment</td>
                        </tr>
                    </tbody>
                </table>
                <div class="pagination-bar" id="closed-trades-pagination"></div>
            </div>
        </section>

        <footer>
            <p>Letzte Aktualisierung: <span th:text="${account.lastSeen}">2026-02-09
                    20:30:00</span> <span style="margin-left: 10px; opacity: 0.5;">v1.1</span></p>
        </footer>
    </div>

    <script th:inline="javascript">

        // ============ HISTORY CHART MANAGER ============
        function HistoryChartManager(canvasId, currentBalance, allRows) {
            this.canvas = document.getElementById(canvasId);
            this.currentBalance = currentBalance;
            this.allTrades = []; // { time: timestamp, profit: float }
            this.chart = null;

            // Parse all trades once
            // Rows are typically sorted by Close Time Descending in the HTML (backend sort)
            // But we need to verify/sort to be sure.
            this.parseData(allRows);
        }

        HistoryChartManager.prototype.parseData = function (rows) {
            var data = [];
            rows.forEach(row => {
                var timeStr = row.dataset.closeTime;
                var profitCell = row.querySelector('.profit-cell');
                var profit = parseFloat(profitCell ? profitCell.dataset.profit : 0);

                if (timeStr) {
                    var t = timeStr.split(/[- :.]/);
                    var date = new Date(t[0], t[1] - 1, t[2], t[3], t[4], t[5]);
                    data.push({
                        time: date.getTime(),
                        profit: profit,
                        dateObj: date,
                        dateStr: timeStr
                    });
                }
            });

            // Sort by Time Ascending for calculation
            data.sort((a, b) => a.time - b.time);
            this.allTrades = data;
        };

        HistoryChartManager.prototype.updateChart = function (range) {
            if (!this.canvas) return;

            // 1. Determine Start Time based on Range
            var now = new Date();
            var minTime = 0;
            switch (range) {
                case 'today':
                    minTime = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
                    break;
                case '1week':
                    minTime = now.getTime() - 7 * 24 * 3600 * 1000;
                    break;
                case '1month':
                    var m = new Date(now);
                    m.setMonth(now.getMonth() - 1);
                    minTime = m.getTime();
                    break;
                case 'thismonth':
                    minTime = new Date(now.getFullYear(), now.getMonth(), 1).getTime();
                    break;
                case '6months':
                    var m6 = new Date(now);
                    m6.setMonth(now.getMonth() - 6);
                    minTime = m6.getTime();
                    break;
                case 'thisyear':
                    minTime = new Date(now.getFullYear(), 0, 1).getTime();
                    break;
                case '1year':
                    var y1 = new Date(now);
                    y1.setFullYear(now.getFullYear() - 1);
                    minTime = y1.getTime();
                    break;
                default:
                    minTime = 0;
            }

            // 2. Calculate Balance History
            // We know the FINAL balance (currentBalance).
            // We work BACKWARDS from the end to find the balance at each point?
            // OR: We calculate total profit of ALL trades, subtract from Current Balance to find Initial Balance?
            // NOTE: Current Balance includes deposits/withdrawals that might NOT be in the trade list if they are filtered out or different type.
            // Assumption: The trade list contains all relevant P/L operations or we only show "Cumulative P/L" curve?
            // User requested "EquityCurve", but usually Balance Curve is what is shown for history.
            // Let's try to reconstruct Balance relative to NOW.

            // Reconstruct:
            // Balance[Now] = CurrentBalance
            // Balance[LastTrade] = CurrentBalance
            // Balance[BeforeLastTrade] = Balance[LastTrade] - LastTradeProfit

            // We iterate backwards through ALL trades (even those older than filter) to find the balance state.

            var fullBalanceHistory = [];
            var runningBalance = this.currentBalance;

            // Add "Now" point
            fullBalanceHistory.push({ x: now.getTime(), y: runningBalance });

            // Iterate BACKWARDS through sorted trades (newest to oldest)
            for (var i = this.allTrades.length - 1; i >= 0; i--) {
                var trade = this.allTrades[i];
                // Record state AFTER trade (which is runningBalance)
                // Actually, the trade closed at trade.time. The balance became runningBalance AT trade.time.
                // So (trade.time, runningBalance) is a point.
                fullBalanceHistory.push({ x: trade.time, y: runningBalance });

                // Revert balance for previous state
                runningBalance -= trade.profit;
            }
            // Add initial state (start of time)
            if (this.allTrades.length > 0) {
                fullBalanceHistory.push({ x: this.allTrades[0].time - 60000, y: runningBalance }); // 1 min before first trade
            }

            // Now we have history from Now -> Past. Reverse it to be Past -> Now.
            fullBalanceHistory.reverse();

            // 3. Filter points for display
            var displayData = fullBalanceHistory.filter(p => p.x >= minTime);

            // Ensure we have at least a starting point if we cut off history
            // Find the last point BEFORE minTime to use as "Open" value
            if (displayData.length === 0 || displayData[0].x > minTime) {
                // Find latest point <= minTime
                var startPoint = { x: minTime, y: this.currentBalance }; // Default fallback
                for (var i = 0; i < fullBalanceHistory.length; i++) {
                    if (fullBalanceHistory[i].x <= minTime) {
                        startPoint = { x: minTime, y: fullBalanceHistory[i].y }; // Balance at start of period
                    } else {
                        break; // optimization: fullBalanceHistory is sorted time asc
                    }
                }
                // Prepend this start point if list is empty or first point is after minTime
                if (displayData.length === 0 || displayData[0].x > minTime) {
                    displayData.unshift(startPoint);
                }
            }

            // 4. Render Chart
            this.render(displayData);
        };

        HistoryChartManager.prototype.render = function (data) {
            var ctx = this.canvas.getContext('2d');
            var labels = data.map(d => new Date(d.x).toLocaleString());
            var values = data.map(d => d.y);

            // Create gradient
            var gradient = ctx.createLinearGradient(0, 0, 0, 300);
            gradient.addColorStop(0, 'rgba(99, 102, 241, 0.5)'); // primary
            gradient.addColorStop(1, 'rgba(99, 102, 241, 0.0)');

            if (this.chart) {
                this.chart.destroy();
            }

            this.chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels, // ChartJS can handle timestamps if using time adapter, but loose labels work too
                    datasets: [{
                        label: 'Balance',
                        data: values, // ChartJS 3+ can take {x,y} objects if parsing is set, but simple array is safer without moment adapter
                        borderColor: '#6366f1',
                        backgroundColor: gradient,
                        borderWidth: 2,
                        pointRadius: data.length > 100 ? 0 : 3, // Hide points if too many
                        pointHoverRadius: 5,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return 'Balance: ' + context.parsed.y.toFixed(2);
                                }
                            },
                            backgroundColor: '#252542',
                            titleColor: '#ffffff',
                            bodyColor: '#a0a0c0',
                            borderColor: '#3f3f5f',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                display: true,
                                color: '#a0a0c0',
                                maxTicksLimit: 8,
                                maxRotation: 0
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            ticks: {
                                color: '#e0e0e0', // Brighter text
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                },
                                callback: function (value) { return value.toFixed(2); }
                            },
                            grid: {
                                color: 'rgba(63,63,95,0.3)'
                            }
                        }
                    }
                }
            });
        };


        // ============ TABLE MANAGER: FILTERING + PAGINATION ============

        function TableManager(tableId, paginationId, summaryId) {
            this.table = document.getElementById(tableId);
            this.paginationBar = document.getElementById(paginationId);
            this.pageSize = 30;
            this.currentPage = 1;
            this.allRows = [];

            if (this.table) {
                this.allRows = Array.from(this.table.querySelectorAll('tbody tr'));
            }
            this.filteredRows = this.allRows; // initially all
        }

        TableManager.prototype.applyFilter = function (filterFn) {
            if (!this.table) return;

            // Filter all rows
            this.filteredRows = [];
            var totalProfit = 0.0;

            this.allRows.forEach(row => {
                var visible = true;
                if (filterFn) {
                    visible = filterFn(row);
                }
                if (visible) {
                    this.filteredRows.push(row);
                    // Sum profit if history table
                    var profitCell = row.querySelector('.profit-cell');
                    if (profitCell) {
                        var val = parseFloat(profitCell.dataset.profit || 0);
                        totalProfit += val;
                    }
                }
            });

            // Update summary if exists
            var countEl = document.getElementById('visible-trades-count');
            var profitAmtEl = document.getElementById('visible-profit-amount');
            var profitLbl = document.getElementById('visible-profit-label');

            if (countEl && profitAmtEl && profitLbl) {
                countEl.textContent = this.filteredRows.length;
                profitAmtEl.textContent = totalProfit.toFixed(2);
                profitLbl.className = totalProfit >= 0 ? 'profit-positive' : 'profit-negative';
            }

            this.showPage(1);
        };

        TableManager.prototype.showPage = function (page) {
            if (!this.table) return;

            this.currentPage = page;
            var totalPages = Math.ceil(this.filteredRows.length / this.pageSize);
            if (totalPages === 0) totalPages = 1;
            if (this.currentPage > totalPages) this.currentPage = totalPages;

            // Hide all first
            this.allRows.forEach(r => r.style.display = 'none');

            // Show current page of filtered rows
            var start = (this.currentPage - 1) * this.pageSize;
            var end = start + this.pageSize;

            for (var i = start; i < end && i < this.filteredRows.length; i++) {
                this.filteredRows[i].style.display = '';
            }

            this.renderPagination(totalPages);
        };

        TableManager.prototype.renderPagination = function (totalPages) {
            if (!this.paginationBar) return;

            // Hide pagination if no pages needed (or minimal)
            if (this.filteredRows.length <= this.pageSize) {
                this.paginationBar.style.display = 'none';
                return;
            }
            this.paginationBar.style.display = 'flex';
            this.paginationBar.innerHTML = '';

            // Left arrow
            var leftBtn = document.createElement('button');
            leftBtn.className = 'page-btn' + (this.currentPage <= 1 ? ' disabled' : '');
            leftBtn.innerHTML = '‚óÄ';
            leftBtn.disabled = this.currentPage <= 1;
            leftBtn.onclick = () => {
                if (this.currentPage > 1) this.showPage(this.currentPage - 1);
            };
            this.paginationBar.appendChild(leftBtn);

            // Page info
            var info = document.createElement('span');
            info.className = 'page-info';
            info.textContent = 'Seite ' + this.currentPage + ' / ' + totalPages +
                ' (' + this.filteredRows.length + ' Trades)';
            this.paginationBar.appendChild(info);

            // Right arrow
            var rightBtn = document.createElement('button');
            rightBtn.className = 'page-btn' + (this.currentPage >= totalPages ? ' disabled' : '');
            rightBtn.innerHTML = '‚ñ∂';
            rightBtn.disabled = this.currentPage >= totalPages;
            rightBtn.onclick = () => {
                if (this.currentPage < totalPages) this.showPage(this.currentPage + 1);
            };
            this.paginationBar.appendChild(rightBtn);
        };

        // Initialize managers
        var openTradesMgr, historyMgr, historyChartMgr, magicChartMgr;

        // Storage key
        var accountId = /*[[${account.accountId}]]*/ '0';
        var currentBalance = /*[[${account.balance}]]*/ 0.0;

        var STORAGE_KEY_FILTER = 'tradeMonitor_filter_' + accountId;

        document.addEventListener('DOMContentLoaded', function () {
            // Open trades: simple pagination, no filtering (always show all open)
            openTradesMgr = new TableManager('open-trades-table', 'open-trades-pagination', null);
            openTradesMgr.applyFilter(null); // Just init

            // History trades: Setup filters
            historyMgr = new TableManager('closed-trades-table', 'closed-trades-pagination', 'history-summary');

            // History Chart
            // Need all rows from history table
            var allHistoryRows = Array.from(document.querySelectorAll('#closed-trades-table tbody tr'));
            historyChartMgr = new HistoryChartManager('balance-history-chart', currentBalance, allHistoryRows);

            // Magic Chart Manager
            magicChartMgr = new MagicChartManager('magic-charts-container');

            // Restore filter
            var savedFilter = localStorage.getItem(STORAGE_KEY_FILTER) || 'thismonth';

            // Filter click handlers
            var btns = document.querySelectorAll('.filter-btn');
            btns.forEach(btn => {
                // Set initial active state
                var range = btn.dataset.range;
                if (range === savedFilter) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }

                btn.addEventListener('click', function () {
                    // Update active class
                    btns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');

                    var r = this.dataset.range;
                    localStorage.setItem(STORAGE_KEY_FILTER, r);
                    applyHistoryFilter(r);
                });
            });

            // Default filter: Saved or Today
            applyHistoryFilter(savedFilter);
        });

        function applyHistoryFilter(range) {
            // Update Table
            if (historyMgr) {
                var now = new Date();
                var todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();

                historyMgr.applyFilter(function (row) {
                    var closeTimeStr = row.dataset.closeTime;
                    if (!closeTimeStr) return false;

                    var t = closeTimeStr.split(/[- :.]/);
                    var tradeDate = new Date(t[0], t[1] - 1, t[2], t[3], t[4], t[5]);
                    var tradeTs = tradeDate.getTime();

                    switch (range) {
                        case 'today': return tradeTs >= todayStart;
                        case '1week': return tradeTs >= (now.getTime() - 7 * 24 * 3600 * 1000);
                        case '1month':
                            var m = new Date(now); m.setMonth(now.getMonth() - 1); return tradeTs >= m.getTime();
                        case 'thismonth':
                            var tm = new Date(now.getFullYear(), now.getMonth(), 1); return tradeTs >= tm.getTime();
                        case '6months':
                            var m6 = new Date(now); m6.setMonth(now.getMonth() - 6); return tradeTs >= m6.getTime();
                        case 'thisyear':
                            var y = new Date(now.getFullYear(), 0, 1); return tradeTs >= y.getTime();
                        case '1year':
                            var y1 = new Date(now); y1.setFullYear(now.getFullYear() - 1); return tradeTs >= y1.getTime();
                        case 'all': default: return true;
                    }
                });
            }

            // Update Chart
            if (historyChartMgr) {
                historyChartMgr.updateChart(range);
            }

            // Update Stats
            updateStats(range);

            // Update Magic Table
            updateMagicStats(range);

            // Update Magic Charts
            if (magicChartMgr && historyMgr) {
                magicChartMgr.update(historyMgr.filteredRows);
            }

            // Update Period Label in Header (Charts)
            var periodLabelCharts = document.getElementById('magic-curves-period');
            // Update Period Label in Header (Table)
            var periodLabelTable = document.getElementById('magic-breakdown-period');

            var rangeName = '';
            var btn = document.querySelector('.filter-btn[data-range="' + range + '"]');
            if (btn) rangeName = btn.textContent;
            var labelText = rangeName ? '(' + rangeName + ')' : '';

            if (periodLabelCharts) periodLabelCharts.textContent = labelText;
            if (periodLabelTable) periodLabelTable.textContent = labelText;
        }

        function updateStats(range) {
            if (!historyMgr) return;

            var trades = historyMgr.filteredRows.map(row => {
                var profitCell = row.querySelector('.profit-cell');
                return parseFloat(profitCell ? profitCell.dataset.profit : 0);
            });

            var totalProfit = 0;
            var grossProfit = 0;
            var grossLoss = 0;
            var wins = 0;
            var losses = 0;
            var totalTrades = trades.length;

            trades.forEach(p => {
                totalProfit += p;
                if (p > 0) {
                    grossProfit += p;
                    wins++;
                } else {
                    grossLoss += Math.abs(p);
                    if (p < 0) losses++;
                }
            });

            var profitFactor = grossLoss === 0 ? (grossProfit > 0 ? 999.99 : 0) : (grossProfit / grossLoss);
            var winRate = totalTrades === 0 ? 0 : (wins / totalTrades) * 100;
            var avgWin = wins === 0 ? 0 : grossProfit / wins;
            var avgLoss = losses === 0 ? 0 : grossLoss / losses; // as positive number

            // Update Stats Grid
            var elProfit = document.getElementById('stat-total-profit');
            if (elProfit) {
                elProfit.textContent = totalProfit.toFixed(2);
                elProfit.className = totalProfit >= 0 ? 'profit-positive' : 'profit-negative';
                elProfit.style.fontSize = "1.25rem";
                elProfit.style.fontWeight = "bold";
            }

            var elPF = document.getElementById('stat-profit-factor');
            if (elPF) elPF.textContent = profitFactor.toFixed(2);

            var elWR = document.getElementById('stat-win-rate');
            if (elWR) elWR.textContent = winRate.toFixed(1) + '%';

            var elTrades = document.getElementById('stat-total-trades');
            if (elTrades) elTrades.textContent = totalTrades;

            var elAvg = document.getElementById('stat-avg-win-loss');
            if (elAvg) elAvg.textContent = avgWin.toFixed(2) + ' / -' + avgLoss.toFixed(2);
        }

        function updateMagicStats(range) {
            // Re-calculate statistics for the Magic Table based on historyMgr.filteredRows
            // 1. Reset counters map
            var magicStats = {}; // { magic: { closedCount: 0, closedProfit: 0.0 } }

            // 2. Aggregate from filtered history
            if (historyMgr && historyMgr.filteredRows) {
                historyMgr.filteredRows.forEach(row => {
                    // find magic cell - it's the 10th column (index 9)
                    var cells = row.querySelectorAll('td');
                    if (cells.length > 9) {
                        var magic = cells[9].textContent.trim();
                        var profit = parseFloat(row.querySelector('.profit-cell').dataset.profit || 0);

                        if (!magicStats[magic]) {
                            magicStats[magic] = { closedCount: 0, closedProfit: 0.0 };
                        }
                        magicStats[magic].closedCount++;
                        magicStats[magic].closedProfit += profit;
                    }
                });
            }

            // 3. Update the Magic Table DOM
            var magicRows = document.querySelectorAll('.magic-breakdown tbody tr');
            magicRows.forEach(row => {
                var magicCell = row.querySelector('td:nth-child(1) strong');
                if (!magicCell) return;
                var magic = magicCell.textContent.trim();

                var stats = magicStats[magic] || { closedCount: 0, closedProfit: 0.0 };

                // Open Profit (Static, from DOM as it was originally rendered)
                var openProfitCell = row.querySelector('td:nth-child(3)');
                var openProfit = parseFloat(openProfitCell ? openProfitCell.textContent : 0);

                // Update Closed Count
                var closedCountCell = row.querySelector('td:nth-child(4)');
                if (closedCountCell) closedCountCell.textContent = stats.closedCount;

                // Update Closed Profit
                var closedProfitCell = row.querySelector('td:nth-child(5)');
                if (closedProfitCell) {
                    closedProfitCell.textContent = stats.closedProfit.toFixed(2);
                    closedProfitCell.className = stats.closedProfit >= 0 ? 'profit-positive' : 'profit-negative';
                }

                // Update Total Profit (Closed + Open)
                var totalProfit = openProfit + stats.closedProfit;
                var totalProfitCell = row.querySelector('td:nth-child(6)');
                if (totalProfitCell) {
                    totalProfitCell.textContent = totalProfit.toFixed(2);
                    totalProfitCell.className = totalProfit >= 0 ? 'profit-positive' : 'profit-negative';
                }
            });
        }


        // ============ MAGIC CHART MANAGER ============
        function MagicChartManager(containerId) {
            this.container = document.getElementById(containerId);
            this.charts = {}; // { magic: ChartInstance }
            this.colors = [
                { line: '#6366f1', bg: 'rgba(99,102,241,0.15)' },
                { line: '#10b981', bg: 'rgba(16,185,129,0.15)' },
                { line: '#f59e0b', bg: 'rgba(245,158,11,0.15)' },
                { line: '#ef4444', bg: 'rgba(239,68,68,0.15)' },
                { line: '#8b5cf6', bg: 'rgba(139,92,246,0.15)' },
                { line: '#ec4899', bg: 'rgba(236,72,153,0.15)' },
                { line: '#14b8a6', bg: 'rgba(20,184,166,0.15)' },
                { line: '#f97316', bg: 'rgba(249,115,22,0.15)' }
            ];
        }

        MagicChartManager.prototype.update = function (rows) {
            if (!this.container) return;

            // 1. Group trades by Magic
            var magicData = {}; // { magic: [ { time, profit } ] }

            rows.forEach(row => {
                var cells = row.querySelectorAll('td');
                if (cells.length > 9) {
                    var magic = cells[9].textContent.trim();
                    var profit = parseFloat(row.querySelector('.profit-cell').dataset.profit || 0);
                    var timeStr = row.dataset.closeTime;

                    if (timeStr) {
                        var t = timeStr.split(/[- :.]/);
                        var date = new Date(t[0], t[1] - 1, t[2], t[3], t[4], t[5]);

                        if (!magicData[magic]) magicData[magic] = [];
                        magicData[magic].push({ time: date.getTime(), profit: profit, dateObj: date });
                    }
                }
            });

            // 2. Identify active magics and existing charts
            var activeMagics = Object.keys(magicData);

            // Remove charts for magics that are no longer present in filtered data
            // Actually, maybe we just hide them? Or destroy them.
            // Let's destroy to keep it clean, or keep them if we want to preserve state?
            // Re-rendering is safer for now.

            this.container.innerHTML = ''; // Clear container
            this.charts = {}; // Reset charts

            if (activeMagics.length === 0) {
                this.container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 1rem;">Keine Daten f√ºr diesen Zeitraum</p>';
                return;
            }

            // 3. Render Charts
            var idx = 0;
            activeMagics.sort(); // Sort by magic number

            activeMagics.forEach(magic => {
                var trades = magicData[magic];
                trades.sort((a, b) => a.time - b.time); // Sort by time asc

                // Calculate Cumulative Profit for this period
                // Note: This starts at 0 for the beginning of the selected period.
                // It does NOT show total lifetime profit if filtered. This is standard behavior for "Profit in Period".
                var dataPoints = [];
                var runProfit = 0;

                // Add start point
                if (trades.length > 0) {
                    dataPoints.push({ x: trades[0].time - 60000, y: 0 });
                }

                trades.forEach(t => {
                    runProfit += t.profit;
                    dataPoints.push({ x: t.time, y: runProfit });
                });

                // Get Color
                var colorSet = this.colors[idx % this.colors.length];
                idx++;

                // Create Chart Elements
                // Build chart label - Try to find a comment from the latest trade
                var commentText = '';
                // Or try to find it in the Magic Breakdown table?
                // Let's look up the Magic Table for a name
                var magicRow = Array.from(document.querySelectorAll('.magic-breakdown tbody tr')).find(r => {
                    var c = r.querySelector('td:nth-child(1) strong');
                    return c && c.textContent.trim() === magic;
                });
                if (magicRow) {
                    var nameDiv = magicRow.querySelector('div');
                    if (nameDiv) commentText = nameDiv.textContent.trim();
                }

                var chartLabel = 'Magic ' + magic + (commentText ? ' ‚Äî ' + commentText : '');
                var labels = dataPoints.map(d => new Date(d.x).toLocaleString());
                var values = dataPoints.map(d => d.y);

                var wrapper = document.createElement('div');
                wrapper.className = 'chart-card';
                wrapper.style.cursor = 'pointer';
                wrapper.dataset.magic = magic;

                var title = document.createElement('h3');
                title.className = 'chart-title';
                title.textContent = chartLabel;
                wrapper.appendChild(title);

                var canvasWrap = document.createElement('div');
                canvasWrap.className = 'chart-container';
                var canvas = document.createElement('canvas');
                canvasWrap.appendChild(canvas);
                wrapper.appendChild(canvasWrap);
                this.container.appendChild(wrapper);

                new Chart(canvas, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: chartLabel,
                            data: values,
                            borderColor: colorSet.line,
                            backgroundColor: colorSet.bg,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 2,
                            pointHoverRadius: 5,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        return 'Profit: ' + context.parsed.y.toFixed(2);
                                    }
                                },
                                backgroundColor: '#252542',
                                titleColor: '#ffffff',
                                bodyColor: '#a0a0c0',
                                borderColor: '#3f3f5f',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                display: true, // Show X axis labels
                                ticks: {
                                    color: '#6b6b8f',
                                    maxRotation: 0,
                                    maxTicksLimit: 6, // Limit ticks to avoid clutter
                                    font: { size: 9 },
                                    autoSkip: true
                                },
                                grid: { display: false } // Keep grid hidden for cleanliness
                            },
                            y: {
                                ticks: { color: '#6b6b8f', font: { size: 10 } },
                                grid: { color: 'rgba(63,63,95,0.3)' }
                            }
                        }
                    }
                });

                // Click handler
                wrapper.onclick = function () {
                    openChartModal(magic, colorSet.line, colorSet.bg, chartLabel, labels, values);
                };
            });
        };

        // ============ FULLSCREEN CHART MODAL ============
        // ============ FULLSCREEN CHART MODAL ============
        var modalChart = null;
        var currentMagic = null;

        function openChartModal(magic, lineColor, bgColor, label, labels, data) {
            currentMagic = magic;
            var modal = document.getElementById('chart-modal');
            var titleEl = document.getElementById('chart-modal-title');
            var canvas = document.getElementById('chart-modal-canvas');

            // Setup Title Editing
            // 1. Parse current comment from label "Magic 12345 ‚Äî [Comment]"
            var magicPrefix = 'Magic ' + magic;
            var commentText = '';
            if (label.indexOf('‚Äî') > 0) {
                commentText = label.split('‚Äî')[1].trim();
            }

            titleEl.innerHTML = `
                <span>${magicPrefix}</span>
                <span id="modal-comment-display" style="margin-left: 10px; color: #a0a0c0; font-weight: normal;">${commentText ? '‚Äî ' + commentText : ''}</span>
                <button id="modal-edit-btn" style="background: none; border: none; cursor: pointer; color: #6366f1; margin-left: 10px; font-size: 1.2rem;">‚úé</button>
                <div id="modal-edit-form" style="display: none; margin-left: 10px;">
                    <input type="text" id="modal-comment-input" value="${commentText}" placeholder="Kommentar..." 
                           style="background: #1e1e38; border: 1px solid #3f3f5f; color: #ffffff; padding: 4px 8px; border-radius: 4px;">
                    <button id="modal-save-btn" style="background: #10b981; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">üíæ</button>
                    <button id="modal-cancel-btn" style="background: #ef4444; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 5px;">‚úï</button>
                </div>
            `;

            // Elements
            var editBtn = document.getElementById('modal-edit-btn');
            var editForm = document.getElementById('modal-edit-form');
            var commentDisplay = document.getElementById('modal-comment-display');
            var input = document.getElementById('modal-comment-input');
            var saveBtn = document.getElementById('modal-save-btn');
            var cancelBtn = document.getElementById('modal-cancel-btn');

            // Event Handlers
            editBtn.onclick = function () {
                editBtn.style.display = 'none';
                commentDisplay.style.display = 'none';
                editForm.style.display = 'inline-flex';
                input.focus();
            };

            cancelBtn.onclick = function () {
                editForm.style.display = 'none';
                editBtn.style.display = 'inline';
                commentDisplay.style.display = 'inline';
                input.value = commentText; // reset
            };

            saveBtn.onclick = function () {
                var newComment = input.value.trim();

                // AJAX Save
                var formData = new FormData();
                formData.append('magicNumber', currentMagic);
                formData.append('customComment', newComment);

                fetch('/api/mapping', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        if (response.ok) {
                            // Update UI locally
                            commentText = newComment;
                            commentDisplay.textContent = newComment ? '‚Äî ' + newComment : '';

                            // Close edit mode
                            editForm.style.display = 'none';
                            editBtn.style.display = 'inline';
                            commentDisplay.style.display = 'inline';

                            // Update Chart Title/Lable in dataset if we want (optional, requires chart update)
                            // Ideally we would reload the page or update the main list entry too. 
                            // For now, modal update is enough feedback.
                        } else {
                            alert('Fehler beim Speichern');
                        }
                    })
                    .catch(err => {
                        console.error(err);
                        alert('Netzwerkfehler');
                    });
            };


            modal.classList.add('visible');

            if (modalChart) { modalChart.destroy(); }

            modalChart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: lineColor,
                        backgroundColor: bgColor,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        borderWidth: 2.5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#a0a0c0', font: { size: 14 } }
                        },
                        tooltip: {
                            backgroundColor: '#252542',
                            titleColor: '#ffffff',
                            bodyColor: '#a0a0c0',
                            borderColor: '#3f3f5f',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#6b6b8f', maxRotation: 45, maxTicksLimit: 20, font: { size: 11 } },
                            grid: { color: 'rgba(63,63,95,0.3)' }
                        },
                        y: {
                            ticks: { color: '#6b6b8f', font: { size: 12 } },
                            grid: { color: 'rgba(63,63,95,0.3)' }
                        }
                    }
                }
            });
        }

        function closeChartModal() {
            var modal = document.getElementById('chart-modal');
            modal.classList.remove('visible');
            if (modalChart) { modalChart.destroy(); modalChart = null; }
        }

        document.getElementById('chart-modal-close').addEventListener('click', closeChartModal);
        document.getElementById('chart-modal').addEventListener('click', function (e) {
            if (e.target === this) closeChartModal();
        });
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') closeChartModal();
        });
    </script>
</body>

</html>